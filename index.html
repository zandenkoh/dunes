<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dunes</title>
    <link rel="icon" href="dune.jpg" type="image/x-icon">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #F4E8D1;
            /* Light sandy color for desert theme */
            font-family: Arial, sans-serif;
        }

        #canvas {
            display: block;
            background: #F4E8D1;
            /* Desert background */
        }

        #minimap {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            border: 2px solid #8B4513;
            /* Brown border for desert feel */
            background: rgba(244, 232, 209, 0.7);
            border-radius: 10px;
        }

        #leaderboard {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #4A2C0B;
            /* Darker brown for better contrast */
            padding: 10px 0;
            background: rgba(244, 232, 209, 0.5);
            border: 2px solid #8B4513;
            border-radius: 12px;
            width: 220px;
            font-family: 'Georgia', serif;
            /* More elegant, readable font */
            font-size: 14px;
            /* Slightly larger text */
            line-height: 1.6;
            /* Improved line spacing */
        }

        #leaderboard h3 {
            margin: 0 0 15px;
            font-size: 18px;
            /* Larger title */
            text-align: center;
            color: #8B4513;
            /* Desert brown for theme consistency */
            border-bottom: 1px solid #A0522D;
            /* Subtle underline */
            padding-bottom: 8px;
        }

        #leaderboard ol {
            margin: 0;
            padding-left: 20px;
            /* Proper indent for list */
            list-style-position: outside;
        }

        #leaderboard li {
            margin-bottom: 8px;
            /* Space between entries */
            display: flex;
            justify-content: space-between;
            /* Align name and stats */
            align-items: center;
            padding: 5px 8px;
            border-radius: 5px;
            transition: background 0.2s;
            /* Smooth hover effect */
        }

        #leaderboard li:hover {
            background: rgba(139, 69, 19, 0.1);
            /* Light hover effect */
        }

        #leaderboard li::marker {
            color: #A0522D;
            /* Custom bullet color */
            font-weight: bold;
        }

        /* Style for player names and stats */
        #leaderboard li span.name {
            flex: 1;
            font-weight: bold;
            color: #4A2C0B;
        }

        #leaderboard li span.stats {
            flex: 0 0 auto;
            color: #6B3F0E;
            /* Slightly lighter for stats */
            font-size: 13px;
        }

        #hud {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #8B4513;
            background: rgba(244, 232, 209, 0.8);
            padding: 15px;
            border-radius: 15px;
            display: flex;
            justify-content: space-around;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .stat {
            text-align: center;
        }

        .stat label {
            font-weight: bold;
        }

        .cooldown {
            width: 100px;
            height: 10px;
            background: #DDD;
            border-radius: 5px;
            margin-top: 5px;
        }

        .cooldown-fill {
            height: 100%;
            background: #4CAF50;
            border-radius: 5px;
            transition: width 0.2s;
        }

        #login {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: rgba(244, 232, 209, 0.9);
            padding: 30px;
            color: #8B4513;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        #login input {
            padding: 12px;
            margin: 10px 0;
            width: 200px;
            border-radius: 5px;
            border: 1px solid #8B4513;
            background: rgba(255, 255, 255, 0.5);
            color: #8B4513;
        }

        #login button {
            padding: 12px 20px;
            background: #8B4513;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }

        #login button:hover {
            background: #A0522D;
        }

        #error {
            color: red;
            margin-top: 10px;
        }

        .power-up {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        #help-button {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: #8B4513;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        #help-button:hover {
            background: #A0522D;
        }

        #manual-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 20;
            overflow-y: auto;
        }

        #manual-content {
            background: rgba(244, 232, 209, 0.9);
            color: #8B4513;
            margin: 5% auto;
            padding: 20px;
            border-radius: 15px;
            max-width: 800px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            font-size: 16px;
            line-height: 1.5;
        }

        #manual-content h2 {
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
        }

        #manual-content h3 {
            font-size: 20px;
            margin-top: 20px;
        }

        #manual-content p,
        #manual-content ul {
            margin: 10px 0;
        }

        #manual-content ul {
            padding-left: 20px;
        }

        #close-manual {
            display: block;
            margin: 20px auto;
            padding: 12px 20px;
            background: #8B4513;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        #close-manual:hover {
            background: #A0522D;
        }

        #loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(244, 232, 209, 0.9);
            z-index: 15;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #8B4513;
            font-size: 24px;
            font-family: Arial, sans-serif;
            text-align: center;
        }

        #loading-overlay::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #8B4513;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="login">
        <h2>Dunes</h2>
        <input id="name" placeholder="Enter your name" type="text" maxlength="15">
        <button id="join-button" onclick="joinGame()">Join Battle</button>
        <div id="error"></div>
    </div>
    <canvas id="canvas"></canvas>
    <canvas id="minimap"></canvas>
    <div id="leaderboard"></div>
    <div id="hud">
        <div class="stat">
            <label>Health</label><br>
            <span id="size">10</span>
        </div>
        <div class="stat">
            <label>Kills</label><br>
            <span id="kills">0</span>
        </div>
        <div class="stat">
            <label>Power-Ups</label><br>
            <span id="powerups">None</span>
        </div>
        <div class="stat">
            <label>Sprint (Space)</label><br>
            <div class="cooldown">
                <div id="sprint-cd" class="cooldown-fill" style="width:100%;"></div>
            </div>
        </div>
        <div class="stat">
            <label>Power (E)</label><br>
            <div class="cooldown">
                <div id="rapid-cd" class="cooldown-fill" style="width:100%;"></div>
            </div>
        </div>
    </div>
    <div id="help-button" onclick="openManual()">?</div>
    <div id="manual-overlay">
        <div id="manual-content">
            <h2>Dunes: Player Manual</h2>
            <h3>Objective</h3>
            <p>Grow your ball by collecting golden sand dots and power-ups, eat smaller players, and shoot projectiles
                to dominate the desert arena. Survive and climb the leaderboard by achieving kills and increasing your
                HP!</p>

            <h3>Controls</h3>
            <ul>
                <li><strong>Move</strong>: WASD or Arrow Keys to navigate your ball.</li>
                <li><strong>Aim</strong>: Move your mouse (or drag on touch devices) to aim your barrel.</li>
                <li><strong>Shoot</strong>: Click or tap to fire projectiles (deals 5 damage).</li>
                <li><strong>Sprint</strong>: Press Spacebar to sprint (2x speed, 10s cooldown).</li>
                <li><strong>Rapid Fire</strong>: Press E to activate rapid fire (10s duration, 1min cooldown).</li>
                <li><strong>Prestige</strong>: Press R when your HP is 100 or more to reset to size 10, gain a
                    prestige star, and unlock a gold particle effect.</li>
                <li><strong>Manual</strong>: Click the "?" button in the bottom right to open/close this manual.</li>
            </ul>

            <h3>Game Elements</h3>
            <ul>
                <li><strong>Golden Sand Dots</strong>: Collect these to grow your size by 1 per dot (max size: 300).
                </li>
                <li><strong>Oases</strong>: Blue-green water areas slow your movement by 50%.</li>
                <li><strong>Ruins</strong>: Brown walls block movement and projectiles.</li>
                <li><strong>Players</strong>: Eat players smaller than you (1.1x HP difference) to gain half their
                    HP and a kill. Get hit by projectiles to lose size; if HP drops below 10, you respawn.</li>
            </ul>

            <h3>Power-Ups</h3>
            <p>Collect square power-ups (last 10s):</p>
            <ul>
                <li><strong>Speed (⚡)</strong>: Increases movement speed by 50%.</li>
                <li><strong>Shield (🛡️)</strong>: Reduces projectile damage by 50%.</li>
                <li><strong>Growth (📈)</strong>: Increases HP by 20% (reverts after duration).</li>
                <li><strong>Multi-Shot (🔫)</strong>: Fires three projectiles at once.</li>
            </ul>

            <h3>Prestige System</h3>
            <p>When your HP reaches 100, press R to prestige:</p>
            <ul>
                <li>Resets your HP to 10 and repositions you randomly.</li>
                <li>Earns a prestige star (★) displayed next to your name.</li>
                <li>Adds gold orbiting particles around your ball.</li>
                <li>Prestige count persists across sessions and is shown on the leaderboard.</li>
            </ul>

            <h3>Tips</h3>
            <ul>
                <li>Use oases strategically to slow down pursuers.</li>
                <li>Hide behind ruins to avoid projectiles.</li>
                <li>Check the minimap (top right) to track players and avoid ambushes.</li>
                <li>Prestige to show off your skill with stars and particles!</li>
            </ul>

            <button id="close-manual" onclick="closeManual()">Close</button>
        </div>
    </div>
    <div id="loading-overlay">Loading...</div>


    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <script>
        document.getElementById('name').value = localStorage.getItem('playerName') || '';

        // Firebase config remains the same
        const firebaseConfig = {
            apiKey: "AIzaSyBh1NkpV56EFJBRyQMKCwQPvchAWFU6a9E",
            authDomain: "empire-realms.firebaseapp.com",
            databaseURL: "https://empire-realms-default-rtdb.firebaseio.com",
            projectId: "empire-realms",
            storageBucket: "empire-realms.firebasestorage.app",
            messagingSenderId: "593809853047",
            appId: "1:593809853047:web:9c7bfe0b30aff7fac3d472"
        };

        const app = firebase.initializeApp(firebaseConfig);
        const db = firebase.database(app);

        const COLORS = ['#FF4500', '#FFD700', '#8B4513', '#D2B48C', '#F4A460', '#CD853F', '#A0522D', '#DEB887']; // Desert-inspired colors
        const MAP_SIZE = 5000;
        const INITIAL_RADIUS = 10;
        const MAX_RADIUS = 300;
        const BASE_SPEED = 5;
        const SPRINT_MULTIPLIER = 2;
        const SPRINT_COOLDOWN = 10000; // 10s
        const RAPID_FIRE_DURATION = 10000; // 10s
        const RAPID_FIRE_COOLDOWN = 60000; // 1min
        const RAPID_FIRE_RATE = 100; // ms per shot
        const DOT_COUNT = 1000;
        const DOT_RADIUS = 2;
        const POWERUP_RADIUS = 15;
        const PROJ_SPEED = 12;
        const PROJ_RADIUS = 5;
        const PROJ_DAMAGE = 5;
        const BARREL_LENGTH = 1.5;
        const POWERUP_COUNT = 20;
        const POWERUP_TYPES = ['speed', 'shield', 'growth', 'multi-shot'];
        const POWERUP_DURATION = 10000;
        const UPDATE_INTERVAL = 0;
        const DB_UPDATE_INTERVAL = 0;

        const walls = [
            { x: 500, y: 500, w: 10, h: 1000 },
            { x: 1500, y: 1500, w: 1000, h: 10 },
            { x: 2500, y: 500, w: 10, h: 1500 },
            { x: 500, y: 2500, w: 1500, h: 10 },
            { x: 3000, y: 3000, w: 10, h: 1000 },
            { x: 3500, y: 2000, w: 1000, h: 10 },
            { x: 1000, y: 3000, w: 10, h: 800 },
            { x: 4000, y: 1000, w: 800, h: 10 },
            // More walls for complexity and desert ruins feel
            { x: 200, y: 1200, w: 600, h: 10 },
            { x: 2200, y: 800, w: 10, h: 500 },
            { x: 3200, y: 2500, w: 500, h: 10 },
            { x: 400, y: 4000, w: 10, h: 700 },
            { x: 4500, y: 1500, w: 300, h: 10 },
            { x: 1800, y: 3500, w: 10, h: 400 },
            { x: 2800, y: 500, w: 400, h: 10 },
            { x: 3800, y: 3000, w: 10, h: 600 }
        ];

        const waters = [ // Oases in desert
            { x: 1000, y: 1000, w: 500, h: 500 },
            { x: 3000, y: 1000, w: 800, h: 600 },
            { x: 2000, y: 3500, w: 700, h: 400 },
            { x: 500, y: 3500, w: 600, h: 400 },
            { x: 4000, y: 3000, w: 500, h: 500 },
            { x: 1500, y: 400, w: 300, h: 300 },
            { x: 3500, y: 3500, w: 400, h: 400 }
        ];

        let peer;
        let myId;
        let connections = [];
        let players = {};
        let dots = {};
        let powerups = {};
        let projectiles = {};
        let myPlayer = { kills: 0, powerups: [], sprintCooldown: 0, rapidCooldown: 0, isSprinting: false, isRapidFiring: false, spinAngle: 0, prestige: 0 };
        let keys = new Set();
        let lastDbUpdate = 0;
        let lastPeerUpdate = 0;
        let mouseX = 0;
        let mouseY = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let isTouchDevice = 'ontouchstart' in window;
        let rapidFireTimer;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const mctx = minimap.getContext('2d');
        const leaderboard = document.getElementById('leaderboard');
        const hudSize = document.getElementById('size');
        const hudKills = document.getElementById('kills');
        const hudPowerups = document.getElementById('powerups');
        const sprintCd = document.getElementById('sprint-cd');
        const rapidCd = document.getElementById('rapid-cd');
        const PRESTIGE_THRESHOLD = 100; // Minimum radius to prestige
        const PRESTIGE_PARTICLE_COUNT = 5; // Number of particles for cosmetic effect

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            minimap.width = 200;
            minimap.height = 200;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        if (!isTouchDevice) {
            canvas.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            canvas.addEventListener('click', fireProjectile);
        } else {
            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            });
            canvas.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                mouseX = touch.clientX;
                mouseY = touch.clientY;
            });
            canvas.addEventListener('touchend', (e) => {
                if (Math.hypot(mouseX - touchStartX, mouseY - touchStartY) < 20) {
                    fireProjectile();
                }
            });
        }

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (['w', 'a', 's', 'd', 'arrowup', 'arrowleft', 'arrowdown', 'arrowright'].includes(k)) {
                keys.add(k);
            } else if (k === ' ') {
                if (myPlayer.sprintCooldown === 0) {
                    myPlayer.isSprinting = true;
                }
            } else if (k === 'e') {
                if (myPlayer.rapidCooldown === 0 && !myPlayer.isRapidFiring) {
                    startRapidFire();
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (['w', 'a', 's', 'd', 'arrowup', 'arrowleft', 'arrowdown', 'arrowright'].includes(k)) {
                keys.delete(k);
            } else if (k === ' ') {
                if (myPlayer.isSprinting) {
                    myPlayer.isSprinting = false;
                    myPlayer.sprintCooldown = SPRINT_COOLDOWN;
                    setTimeout(() => { myPlayer.sprintCooldown = 0; }, SPRINT_COOLDOWN);
                }
            }
        });

        document.addEventListener('visibilitychange', updateActivity);

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (['w', 'a', 's', 'd', 'arrowup', 'arrowleft', 'arrowdown', 'arrowright'].includes(k)) {
                keys.add(k);
            } else if (k === ' ') {
                if (myPlayer.sprintCooldown === 0) {
                    myPlayer.isSprinting = true;
                }
            } else if (k === 'e') {
                if (myPlayer.rapidCooldown === 0 && !myPlayer.isRapidFiring) {
                    startRapidFire();
                }
            } else if (k === 'r' && myPlayer.radius >= PRESTIGE_THRESHOLD) {
                prestigeReset();
            }
        });

        function openManual() {
            document.getElementById('manual-overlay').style.display = 'block';
        }

        function closeManual() {
            document.getElementById('manual-overlay').style.display = 'none';
        }

        function prestigeReset() {
            myPlayer.prestige = (myPlayer.prestige || 0) + 1;
            myPlayer.radius = INITIAL_RADIUS;
            let newX = Math.random() * MAP_SIZE;
            let newY = Math.random() * MAP_SIZE;
            while (intersectsWall(newX, newY, INITIAL_RADIUS) || isInWater(newX, newY)) {
                newX = Math.random() * MAP_SIZE;
                newY = Math.random() * MAP_SIZE;
            }
            myPlayer.x = newX;
            myPlayer.y = newY;
            localStorage.setItem('playerPrestige_' + myPlayer.name, myPlayer.prestige);
            updateDbPlayer();
            broadcastUpdate(true);
        }

        // Initial setup for handling saved names
        const savedName = localStorage.getItem('playerName');
        if (savedName) {
            document.getElementById('name').value = savedName;
            document.getElementById('loading-overlay').style.display = 'flex'; // Show loading for returning users
            document.getElementById('login').style.display = 'none'; // Hide login screen
            document.getElementById('minimap').style.display = 'none'; // Hide minimap
            document.getElementById('leaderboard').style.display = 'none'; // Hide leaderboard
            document.getElementById('hud').style.display = 'none'; // Hide HUD
            joinGame(); // Auto-login for returning users
        } else {
            // For new users, ensure login is visible and loading is hidden
            document.getElementById('login').style.display = 'block';
            document.getElementById('loading-overlay').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
        }

        function updateActivity() {
            myPlayer.active = document.visibilityState === 'visible';
            broadcastUpdate();
            updateDbPlayer();
        }

        function joinGame() {
            const name = document.getElementById('name').value.trim();
            if (!name || name.length < 3) {
                document.getElementById('error').textContent = 'Name must be at least 3 characters!';
                return;
            }
            // Disable join button and show loading screen
            const joinButton = document.getElementById('join-button');
            joinButton.disabled = true;
            document.getElementById('loading-overlay').style.display = 'flex';
            document.getElementById('login').style.display = 'none';
            localStorage.setItem('playerName', name);
            initGame(name);
        }

        function initGame(name) {
            peer = new Peer();

            peer.on('connection', (conn) => {
                conn.on('open', () => {
                    connections.push(conn);
                    conn.send({ type: 'update', x: myPlayer.x, y: myPlayer.y, radius: myPlayer.radius, angle: myPlayer.angle, active: myPlayer.active, kills: myPlayer.kills, prestige: myPlayer.prestige, projectiles: Object.values(projectiles).filter(proj => proj.owner === myId).map(proj => ({ id: proj.id, x: proj.x, y: proj.y, vx: proj.vx, vy: proj.vy, radius: proj.radius })) });
                });
                conn.on('data', handlePeerData.bind(conn));
                conn.on('close', () => {
                    connections = connections.filter(c => c !== conn);
                });
            });

            peer.on('open', (id) => {
                myId = id;
                db.ref('players').once('value').then((snapshot) => {
                    const existingPlayers = snapshot.val() || {};
                    let oldId = null;
                    let oldPlayer = null;
                    for (let id in existingPlayers) {
                        if (existingPlayers[id].name === name) {
                            oldId = id;
                            oldPlayer = existingPlayers[id];
                            break;
                        }
                    }
                    let color, x, y, radius, kills, angle, secret, prestige;
                    if (oldPlayer) {
                        const localSecret = localStorage.getItem('playerSecret_' + name);
                        if (localSecret !== oldPlayer.secret) {
                            document.getElementById('error').textContent = 'Name is taken by another user!';
                            document.getElementById('login').style.display = 'block';
                            document.getElementById('loading-overlay').style.display = 'none';
                            document.getElementById('join-button').disabled = false;
                            return;
                        }
                        db.ref(`players/${oldId}`).remove();
                        color = oldPlayer.color;
                        x = oldPlayer.x;
                        y = oldPlayer.y;
                        radius = oldPlayer.radius;
                        kills = oldPlayer.kills;
                        angle = oldPlayer.angle;
                        secret = oldPlayer.secret;
                        prestige = oldPlayer.prestige || 0;
                    } else {
                        const playerCount = Object.keys(existingPlayers).length;
                        color = COLORS[playerCount % COLORS.length];
                        x = Math.random() * MAP_SIZE;
                        y = Math.random() * MAP_SIZE;
                        while (intersectsWall(x, y, INITIAL_RADIUS) || isInWater(x, y)) {
                            x = Math.random() * MAP_SIZE;
                            y = Math.random() * MAP_SIZE;
                        }
                        radius = INITIAL_RADIUS;
                        kills = 0;
                        angle = 0;
                        secret = crypto.randomUUID();
                        prestige = parseInt(localStorage.getItem('playerPrestige_' + name)) || 0;
                        localStorage.setItem('playerSecret_' + name, secret);
                    }

                    myPlayer = { ...myPlayer, name, color, x, y, radius, angle, active: true, kills, prestige };
                    players[myId] = myPlayer;

                    db.ref(`players/${myId}`).set({ name, color, x, y, radius, angle, active: true, kills, peerId: myId, lastUpdate: Date.now(), secret, prestige });

                    // Hide loading screen and show UI elements after successful initialization
                    document.getElementById('loading-overlay').style.display = 'none';
                    document.getElementById('minimap').style.display = 'block';
                    document.getElementById('leaderboard').style.display = 'block';
                    document.getElementById('hud').style.display = 'flex';
                    document.getElementById('help-button').style.display = 'block'; // Show help button
                    setupDatabaseListeners();
                    checkAndSpawnDots();
                    checkAndSpawnPowerUps();
                    setInterval(broadcastUpdate, UPDATE_INTERVAL);
                    renderLoop();
                }).catch((error) => {
                    // Handle Firebase errors
                    document.getElementById('error').textContent = 'Failed to connect. Try again!';
                    document.getElementById('login').style.display = 'block';
                    document.getElementById('loading-overlay').style.display = 'none';
                    document.getElementById('join-button').disabled = false;
                });
            });
        }

        function handlePeerData(data) {
            if (data.type === 'update') {
                const p = players[this.peer];
                if (p && data.timestamp > (p.lastUpdate || 0)) { // Only process newer updates
                    p.targetX = data.x;
                    p.targetY = data.y;
                    p.targetRadius = data.radius;
                    p.targetAngle = data.angle;
                    p.active = data.active;
                    p.kills = data.kills;
                    p.prestige = data.prestige || 0;
                    p.lastUpdate = data.timestamp; // Use sender's timestamp
                    if (data.projectiles) {
                        data.projectiles.forEach(proj => {
                            if (proj.owner !== myId) {
                                projectiles[proj.id] = {
                                    id: proj.id,
                                    owner: this.peer,
                                    x: proj.x,
                                    y: proj.y,
                                    vx: proj.vx,
                                    vy: proj.vy,
                                    radius: proj.radius
                                };
                            }
                        });
                    }
                }
            } else if (data.type === 'hit') {
                myPlayer.radius = Math.min(myPlayer.radius + data.amount, MAX_RADIUS);
                if (data.kill) myPlayer.kills++;
                updateDbPlayer();
                broadcastUpdate();
            } else if (data.type === 'eaten') {
                myPlayer.radius = INITIAL_RADIUS;
                let newX = Math.random() * MAP_SIZE;
                let newY = Math.random() * MAP_SIZE;
                while (intersectsWall(newX, newY, INITIAL_RADIUS) || isInWater(newX, newY)) {
                    newX = Math.random() * MAP_SIZE;
                    newY = Math.random() * MAP_SIZE;
                }
                myPlayer.x = newX;
                myPlayer.y = newY;
                updateDbPlayer();
                broadcastUpdate(true);
            } else if (data.type === 'fire') {
                if (!projectiles[data.id]) {
                    projectiles[data.id] = {
                        id: data.id,
                        owner: data.owner,
                        x: data.x,
                        y: data.y,
                        vx: data.vx,
                        vy: data.vy,
                        radius: data.radius
                    };
                }
            } else if (data.type === 'remove_proj') {
                delete projectiles[data.id];
            } else if (data.type === 'remove_powerup') {
                delete powerups[data.id];
            }
        }

        function setupDatabaseListeners() {
            db.ref('players').on('child_added', (snapshot) => {
                const id = snapshot.key;
                if (id === myId) return;
                const val = snapshot.val();
                players[id] = { ...val, targetX: val.x, targetY: val.y, targetRadius: val.radius, targetAngle: val.angle, lastUpdate: Date.now() };
                if (myId < id) {
                    const conn = peer.connect(players[id].peerId);
                    conn.on('open', () => {
                        connections.push(conn);
                        conn.send({ type: 'update', x: myPlayer.x, y: myPlayer.y, radius: myPlayer.radius, angle: myPlayer.angle, active: myPlayer.active, kills: myPlayer.kills });
                    });
                    conn.on('data', handlePeerData.bind(conn));
                    conn.on('close', () => {
                        connections = connections.filter(c => c !== conn);
                    });
                }
            });

            db.ref('players').on('child_changed', (snapshot) => {
                const id = snapshot.key;
                if (id === myId) return;
                const updated = snapshot.val();
                if (players[id]) {
                    players[id].name = updated.name;
                    players[id].color = updated.color;
                    players[id].targetX = updated.x;
                    players[id].targetY = updated.y;
                    players[id].targetRadius = updated.radius;
                    players[id].targetAngle = updated.angle;
                    players[id].active = updated.active;
                    players[id].kills = updated.kills;
                    players[id].lastUpdate = Date.now();
                    if (updated.lastUpdate) players[id].dbLastUpdate = updated.lastUpdate;
                    if (updated.secret) players[id].secret = updated.secret;
                }
            });

            db.ref('players').on('child_removed', (snapshot) => {
                const id = snapshot.key;
                delete players[id];
                connections = connections.filter((c) => c.peer !== id);
            });

            db.ref('dots').on('child_added', (snapshot) => {
                dots[snapshot.key] = snapshot.val();
            });

            db.ref('dots').on('child_removed', (snapshot) => {
                delete dots[snapshot.key];
            });

            db.ref('powerups').on('child_added', (snapshot) => {
                powerups[snapshot.key] = snapshot.val();
            });

            db.ref('powerups').on('child_removed', (snapshot) => {
                delete powerups[snapshot.key];
            });
        }

        function checkAndSpawnDots() {
            db.ref('dots').once('value').then((snapshot) => {
                const currentDots = snapshot.val() || {};
                const count = Object.keys(currentDots).length;
                for (let i = count; i < DOT_COUNT; i++) {
                    spawnDot();
                }
            });
        }

        function spawnDot() {
            let x = Math.random() * MAP_SIZE;
            let y = Math.random() * MAP_SIZE;
            while (intersectsWall(x, y, DOT_RADIUS) || isInWater(x, y)) {
                x = Math.random() * MAP_SIZE;
                y = Math.random() * MAP_SIZE;
            }
            db.ref('dots').push({
                x, y,
                color: '#DAA520', // Golden sand dots
                radius: DOT_RADIUS
            });
        }

        function checkAndSpawnPowerUps() {
            db.ref('powerups').once('value').then((snapshot) => {
                const currentPowerUps = snapshot.val() || {};
                const count = Object.keys(currentPowerUps).length;
                for (let i = count; i < POWERUP_COUNT; i++) {
                    spawnPowerUp();
                }
            });
        }

        function spawnPowerUp() {
            let x = Math.random() * MAP_SIZE;
            let y = Math.random() * MAP_SIZE;
            while (intersectsWall(x, y, POWERUP_RADIUS) || isInWater(x, y)) {
                x = Math.random() * MAP_SIZE;
                y = Math.random() * MAP_SIZE;
            }
            db.ref('powerups').push({
                x, y,
                type: POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)],
                radius: POWERUP_RADIUS
            });
        }

        function broadcastUpdate(force = false) {
            const now = Date.now();
            if (!force && now - lastPeerUpdate < 30) return; // Throttle to ~33 FPS (30ms)
            lastPeerUpdate = now;
            const data = {
                type: 'update',
                x: Math.round(myPlayer.x * 100) / 100,
                y: Math.round(myPlayer.y * 100) / 100,
                radius: Math.round(myPlayer.radius * 100) / 100,
                angle: Math.round(myPlayer.angle * 100) / 100,
                active: myPlayer.active,
                kills: myPlayer.kills,
                prestige: myPlayer.prestige,
                timestamp: now, // Add timestamp for synchronization
                projectiles: Object.values(projectiles)
                    .filter(proj => proj.owner === myId)
                    .map(proj => ({
                        id: proj.id,
                        x: Math.round(proj.x * 100) / 100,
                        y: Math.round(proj.y * 100) / 100,
                        vx: Math.round(proj.vx * 100) / 100,
                        vy: Math.round(proj.vy * 100) / 100,
                        radius: proj.radius
                    }))
            };
            connections.forEach((conn) => {
                if (conn.open) {
                    conn.send(data);
                }
            });
            if (now - lastDbUpdate > 50) {
                updateDbPlayer();
            }
        }

        function updateDbPlayer() {
            db.ref(`players/${myId}`).update({ x: myPlayer.x, y: myPlayer.y, radius: myPlayer.radius, angle: myPlayer.angle, active: myPlayer.active, kills: myPlayer.kills, lastUpdate: Date.now(), prestige: myPlayer.prestige });
            lastDbUpdate = Date.now();
        }

        function updateAim() {
            const dx = mouseX - canvas.width / 2;
            const dy = mouseY - canvas.height / 2;
            const newAngle = Math.atan2(dy, dx);
            if (Math.abs(newAngle - myPlayer.angle) > 0.01) {
                myPlayer.angle = newAngle;
            }
        }

        function fireSingle(angle) {
            if (!myPlayer) return;
            const projId = Date.now() + Math.random().toString(36).substr(2, 9);
            const dx = Math.cos(angle);
            const dy = Math.sin(angle);
            const projX = myPlayer.x + dx * (myPlayer.radius + PROJ_RADIUS);
            const projY = myPlayer.y + dy * (myPlayer.radius + PROJ_RADIUS);
            const vx = dx * PROJ_SPEED;
            const vy = dy * PROJ_SPEED;
            const proj = { id: projId, owner: myId, x: projX, y: projY, vx, vy, radius: PROJ_RADIUS };
            projectiles[projId] = proj;
            connections.forEach((conn) => {
                if (conn.open) {
                    conn.send({ type: 'fire', id: projId, owner: myId, x: projX, y: projY, vx, vy, radius: PROJ_RADIUS });
                }
            });
        }

        function fireProjectile() {
            const offsets = myPlayer.powerups.includes('multi-shot') ? [-0.2, 0, 0.2] : [0];
            offsets.forEach(offset => {
                fireSingle(myPlayer.angle + offset);
            });
        }

        function startRapidFire() {
            myPlayer.isRapidFiring = true;
            myPlayer.rapidCooldown = RAPID_FIRE_COOLDOWN + RAPID_FIRE_DURATION;
            let elapsed = 0;
            rapidFireTimer = setInterval(() => {
                if (!myPlayer.isRapidFiring) return;
                myPlayer.spinAngle += Math.PI / 10; // Fast spin
                myPlayer.angle += Math.PI / 10; // Rotate aim
                fireProjectile();
                elapsed += RAPID_FIRE_RATE;
                if (elapsed >= RAPID_FIRE_DURATION) {
                    stopRapidFire();
                }
            }, RAPID_FIRE_RATE);
            setTimeout(stopRapidFire, RAPID_FIRE_DURATION);
        }

        function stopRapidFire() {
            myPlayer.isRapidFiring = false;
            clearInterval(rapidFireTimer);
            setTimeout(() => { myPlayer.rapidCooldown = 0; }, RAPID_FIRE_COOLDOWN);
        }

        function intersectsWall(cx, cy, cr) {
            for (const wall of walls) {
                if (cx + cr > wall.x && cx - cr < wall.x + wall.w &&
                    cy + cr > wall.y && cy - cr < wall.y + wall.h) {
                    return true;
                }
            }
            return false;
        }

        function isInWater(cx, cy) {
            for (const water of waters) {
                if (cx > water.x && cx < water.x + water.w &&
                    cy > water.y && cy < water.y + water.h) {
                    return true;
                }
            }
            return false;
        }

        function handleMovement() {
            let vx = 0, vy = 0;
            if (keys.has('a') || keys.has('arrowleft')) vx -= 1;
            if (keys.has('d') || keys.has('arrowright')) vx += 1;
            if (keys.has('w') || keys.has('arrowup')) vy -= 1;
            if (keys.has('s') || keys.has('arrowdown')) vy += 1;

            if (vx || vy) {
                const len = Math.hypot(vx, vy);
                if (len) {
                    vx /= len;
                    vy /= len;
                }
                let speed = BASE_SPEED * Math.pow(myPlayer.radius / INITIAL_RADIUS, -0.1);
                if (myPlayer.powerups.includes('speed')) speed *= 1.5;
                if (myPlayer.isSprinting) speed *= SPRINT_MULTIPLIER;
                if (isInWater(myPlayer.x, myPlayer.y)) speed *= 0.5;
                const newX = myPlayer.x + vx * speed;
                const newY = myPlayer.y + vy * speed;

                if (!intersectsWall(newX, newY, myPlayer.radius) &&
                    newX >= myPlayer.radius && newX <= MAP_SIZE - myPlayer.radius &&
                    newY >= myPlayer.radius && newY <= MAP_SIZE - myPlayer.radius) {
                    myPlayer.x = newX;
                    myPlayer.y = newY;
                }
            }
        }

        function handleCollisions() {
            // Dots
            for (const key in dots) {
                const dot = dots[key];
                const dist = Math.hypot(myPlayer.x - dot.x, myPlayer.y - dot.y);
                if (dist < myPlayer.radius + dot.radius && myPlayer.radius < MAX_RADIUS) {
                    db.ref(`dots/${key}`).remove();
                    myPlayer.radius += 1;
                    spawnDot();
                }
            }

            // Power-ups
            for (const key in powerups) {
                const pu = powerups[key];
                const dist = Math.hypot(myPlayer.x - pu.x, myPlayer.y - pu.y);
                if (dist < myPlayer.radius + pu.radius) {
                    db.ref(`powerups/${key}`).remove();
                    applyPowerUp(pu.type);
                    connections.forEach((conn) => {
                        if (conn.open) {
                            conn.send({ type: 'remove_powerup', id: key });
                        }
                    });
                    spawnPowerUp();
                }
            }

            // Player eating
            for (const id in players) {
                if (id === myId) continue;
                const p = players[id];
                const dist = Math.hypot(myPlayer.x - p.x, myPlayer.y - p.y);
                if (myPlayer.radius > p.radius * 1.1 && dist < myPlayer.radius - p.radius * 0.5) {
                    const old_radius = p.radius;
                    const amount = old_radius / 2;
                    myPlayer.radius = Math.min(myPlayer.radius + amount, MAX_RADIUS);
                    myPlayer.kills++;

                    const conn = connections.find(c => c.peer === id);
                    if (conn && conn.open) {
                        conn.send({ type: 'eaten' });
                    }

                    updateDbPlayer();
                    broadcastUpdate(true);
                    break;
                }
            }

            // Projectiles
            for (const key in projectiles) {
                const proj = projectiles[key];
                if (proj.owner === myId) continue;
                const dist = Math.hypot(myPlayer.x - proj.x, myPlayer.y - proj.y);
                if (dist < myPlayer.radius + proj.radius) {
                    let damage = PROJ_DAMAGE;
                    if (myPlayer.powerups.includes('shield')) damage /= 2;
                    myPlayer.radius -= damage;
                    let killed = false;
                    if (myPlayer.radius < INITIAL_RADIUS) {
                        killed = true;
                        myPlayer.radius = INITIAL_RADIUS;
                        let newX = Math.random() * MAP_SIZE;
                        let newY = Math.random() * MAP_SIZE;
                        while (intersectsWall(newX, newY, INITIAL_RADIUS) || isInWater(newX, newY)) {
                            newX = Math.random() * MAP_SIZE;
                            newY = Math.random() * MAP_SIZE;
                        }
                        myPlayer.x = newX;
                        myPlayer.y = newY;
                    }
                    updateDbPlayer();
                    broadcastUpdate(true);

                    const conn = connections.find(c => c.peer === proj.owner);
                    if (conn && conn.open) {
                        conn.send({ type: 'hit', amount: damage, kill: killed });
                    }

                    connections.forEach((conn) => {
                        if (conn.open) {
                            conn.send({ type: 'remove_proj', id: key });
                        }
                    });
                    delete projectiles[key];
                }
            }
        }

        function applyPowerUp(type) {
            myPlayer.powerups.push(type);
            if (type === 'growth') myPlayer.radius = Math.min(myPlayer.radius * 1.2, MAX_RADIUS);
            setTimeout(() => {
                myPlayer.powerups = myPlayer.powerups.filter(p => p !== type);
                if (type === 'growth') myPlayer.radius /= 1.2;
                updateHud();
            }, POWERUP_DURATION);
            updateHud();
        }

        function updateProjectiles() {
            for (const key in projectiles) {
                const proj = projectiles[key];
                const newX = proj.x + proj.vx;
                const newY = proj.y + proj.vy;
                if (
                    intersectsWall(newX, newY, proj.radius) ||
                    newX < 0 ||
                    newX > MAP_SIZE ||
                    newY < 0 ||
                    newY > MAP_SIZE
                ) {
                    delete projectiles[key];
                    connections.forEach((conn) => {
                        if (conn.open) {
                            conn.send({ type: 'remove_proj', id: key });
                        }
                    });
                    continue;
                }
                proj.x = newX;
                proj.y = newY;
            }
        }

        function interpolatePlayers() {
            const now = Date.now();
            const deltaTime = 16 / 1000; // Assume ~60 FPS (16ms per frame)
            for (const id in players) {
                if (id === myId) continue;
                const p = players[id];
                if (p.targetX !== undefined && p.lastUpdate && now - p.lastUpdate < 2000) { // Extend staleness threshold
                    // Time-based interpolation
                    const timeSinceUpdate = (now - p.lastUpdate) / 1000;
                    const posLerp = Math.min(1, deltaTime / (timeSinceUpdate + 0.1)); // Smooth lerp, avoid division by zero
                    const radiusLerp = Math.min(1, deltaTime / 0.2); // Slower radius changes
                    const angleLerp = Math.min(1, deltaTime / 0.1); // Fast angle updates
                    p.x = p.x ? lerp(p.x, p.targetX, posLerp) : p.targetX;
                    p.y = p.y ? lerp(p.y, p.targetY, posLerp) : p.targetY;
                    p.radius = p.radius ? lerp(p.radius, p.targetRadius, radiusLerp) : p.targetRadius;
                    p.angle = p.angle ? lerpAngle(p.angle, p.targetAngle, angleLerp) : p.targetAngle;
                } else {
                    // Snap to target for very stale data
                    p.x = p.targetX;
                    p.y = p.targetY;
                    p.radius = p.targetRadius;
                    p.angle = p.targetAngle;
                }
            }
        }

        // Helper function for linear interpolation
function lerp(start, end, alpha) {
    return start + (end - start) * alpha;
}

// Helper function for angle interpolation (handles wraparound)
function lerpAngle(start, end, alpha) {
    const diff = ((((end - start) % (Math.PI * 2)) + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
    return start + diff * alpha;
}

        function updateLeaderboard() {
            const sorted = Object.values(players).sort((a, b) => b.kills - a.kills || b.radius - a.radius).slice(0, 10);
            let html = '<h3>Leaderboard</h3><ol>';
            sorted.forEach(p => {
                html += `<li><span class="name">${p.name}${p.prestige > 0 ? ' ★' + p.prestige : ''}</span><span class="stats">${p.kills} Kills | ${Math.floor(p.radius)} HP</span></li>`;
            });
            html += '</ol>';
            leaderboard.innerHTML = html;
        }

        function updateHud() {
            hudSize.textContent = Math.floor(myPlayer.radius);
            hudKills.textContent = myPlayer.kills;
            hudPowerups.textContent = myPlayer.powerups.map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(', ') || 'None';
            sprintCd.style.width = `${(1 - myPlayer.sprintCooldown / SPRINT_COOLDOWN) * 100}%`;
            rapidCd.style.width = `${(1 - myPlayer.rapidCooldown / (RAPID_FIRE_COOLDOWN + RAPID_FIRE_DURATION)) * 100}%`;
            if (myPlayer.sprintCooldown > 0) myPlayer.sprintCooldown -= 16; // Approx frame time
            if (myPlayer.rapidCooldown > 0) myPlayer.rapidCooldown -= 16;
        }

        function renderLoop() {
            updateAim();
            handleMovement();
            updateProjectiles();
            handleCollisions();
            interpolatePlayers();
            broadcastUpdate();

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const camX = canvas.width / 2 - myPlayer.x;
            const camY = canvas.height / 2 - myPlayer.y;
            ctx.save();
            ctx.translate(camX, camY);

            const viewLeft = myPlayer.x - canvas.width / 2;
            const viewRight = myPlayer.x + canvas.width / 2;
            const viewTop = myPlayer.y - canvas.height / 2;
            const viewBottom = myPlayer.y + canvas.height / 2;

            // Draw oases (waters) with blue-green for contrast
            ctx.fillStyle = 'rgba(0, 128, 128, 0.4)'; // Teal oasis
            for (const water of waters) {
                if (water.x + water.w > viewLeft && water.x < viewRight && water.y + water.h > viewTop && water.y < viewBottom) {
                    ctx.fillRect(water.x, water.y, water.w, water.h);
                }
            }

            // Draw grid with subtle sand lines
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.1)'; // Brown grid
            const gridSize = 100;
            const startX = Math.floor(viewLeft / gridSize) * gridSize;
            const startY = Math.floor(viewTop / gridSize) * gridSize;
            for (let i = startX; i <= viewRight; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(i, viewTop);
                ctx.lineTo(i, viewBottom);
                ctx.stroke();
            }
            for (let i = startY; i <= viewBottom; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(viewLeft, i);
                ctx.lineTo(viewRight, i);
                ctx.stroke();
            }

            // Draw walls as rocky brown
            ctx.fillStyle = '#8B4513'; // Brown rocks
            for (const wall of walls) {
                if (wall.x + wall.w > viewLeft && wall.x < viewRight && wall.y + wall.h > viewTop && wall.y < viewBottom) {
                    ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
                }
            }

            // Draw dots
            for (const key in dots) {
                const dot = dots[key];
                if (dot.x > viewLeft && dot.x < viewRight && dot.y > viewTop && dot.y < viewBottom) {
                    ctx.fillStyle = dot.color;
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw power-ups with distinct shapes/icons
            for (const key in powerups) {
                const pu = powerups[key];
                if (pu.x > viewLeft && pu.x < viewRight && pu.y > viewTop && pu.y < viewBottom) {
                    ctx.fillStyle = getPowerUpColor(pu.type);
                    ctx.beginPath();
                    ctx.rect(pu.x - pu.radius, pu.y - pu.radius, pu.radius * 2, pu.radius * 2); // Square for distinction
                    ctx.fill();
                    // Icon text
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(getPowerUpIcon(pu.type), pu.x, pu.y + 4);
                    // Pulse
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.5;
                    ctx.beginPath();
                    ctx.rect(pu.x - pu.radius * 2, pu.y - pu.radius * 2, pu.radius * 4, pu.radius * 4);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }

            // Draw projectiles
            for (const key in projectiles) {
                const proj = projectiles[key];
                if (proj.x > viewLeft && proj.x < viewRight && proj.y > viewTop && proj.y < viewBottom) {
                    ctx.fillStyle = '#FF4500'; // Orange projectiles for desert
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw players
            for (const id in players) {
                const p = players[id];
                if (p.x + p.radius > viewLeft && p.x - p.radius < viewRight && p.y + p.radius > viewTop && p.y - p.radius < viewBottom) {
                    ctx.save();
                    ctx.globalAlpha = p.active ? 1 : 0.5;
                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius);
                    gradient.addColorStop(0, p.color);
                    gradient.addColorStop(1, '#8B4513');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw prestige particles
                    if (p.prestige > 0) {
                        ctx.globalAlpha = 0.7;
                        for (let i = 0; i < PRESTIGE_PARTICLE_COUNT; i++) {
                            const angle = (i / PRESTIGE_PARTICLE_COUNT) * Math.PI * 2 + Date.now() / 500;
                            const px = p.x + Math.cos(angle) * (p.radius + 10);
                            const py = p.y + Math.sin(angle) * (p.radius + 10);
                            ctx.fillStyle = '#FFD700'; // Gold particles
                            ctx.beginPath();
                            ctx.arc(px, py, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = p.active ? 1 : 0.5;
                    }

                    if (p.powerups && p.powerups.includes('shield')) {
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Barrel
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + Math.cos(p.angle) * p.radius * BARREL_LENGTH, p.y + Math.sin(p.angle) * p.radius * BARREL_LENGTH);
                    ctx.stroke();

                    // Name with prestige indicator
                    ctx.fillStyle = '#000';
                    ctx.font = `${Math.max(12, p.radius / 5)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`${p.name}${p.prestige > 0 ? ' ★' + p.prestige : ''}`, p.x, p.y - p.radius - 10);
                    ctx.restore();
                }
            }

            // Spin effect for myPlayer if rapid firing
            if (myPlayer.isRapidFiring) {
                ctx.save();
                ctx.translate(myPlayer.x, myPlayer.y);
                ctx.rotate(myPlayer.spinAngle);
                ctx.translate(-myPlayer.x, -myPlayer.y);
                // Redraw myPlayer with rotation, but since it's circle, add visual lines or something
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(myPlayer.x - myPlayer.radius, myPlayer.y);
                ctx.lineTo(myPlayer.x + myPlayer.radius, myPlayer.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(myPlayer.x, myPlayer.y - myPlayer.radius);
                ctx.lineTo(myPlayer.x, myPlayer.y + myPlayer.radius);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();

            // Draw opponent direction arrows on the border
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const margin = 20;
            const halfW = cx - margin;
            const halfH = cy - margin;

            for (const id in players) {
                if (id === myId || !players[id].active) continue;
                const p = players[id];
                const dx = p.x - myPlayer.x;
                const dy = p.y - myPlayer.y;
                const screenX = cx + dx;
                const screenY = cy + dy;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) continue; // on screen

                if (dx === 0 && dy === 0) continue;

                const absX = Math.abs(dx);
                const absY = Math.abs(dy);
                let posX, posY;
                const angle = Math.atan2(dy, dx);

                if (absX * halfH > absY * halfW) {
                    // Hits left/right
                    posX = dx > 0 ? canvas.width - margin : margin;
                    posY = cy + (posX - cx) * (dy / dx);
                } else {
                    // Hits top/bottom
                    posY = dy > 0 ? canvas.height - margin : margin;
                    posX = cx + (posY - cy) * (dx / dy);
                }

                // Draw arrow
                ctx.save();
                ctx.translate(posX, posY);
                ctx.rotate(angle);
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(20, 0);
                ctx.lineTo(0, 10);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Minimap with desert colors
            mctx.clearRect(0, 0, minimap.width, minimap.height);
            const scale = minimap.width / MAP_SIZE;

            mctx.fillStyle = 'rgba(0, 128, 128, 0.4)';
            for (const water of waters) {
                mctx.fillRect(water.x * scale, water.y * scale, water.w * scale, water.h * scale);
            }

            mctx.fillStyle = '#8B4513';
            for (const wall of walls) {
                mctx.fillRect(wall.x * scale, wall.y * scale, wall.w * scale, wall.h * scale);
            }

            for (const id in players) {
                const p = players[id];
                mctx.globalAlpha = p.active ? 1 : 0.3; // Lower opacity for inactive players
                // Draw player with larger size and distinct outline
                mctx.fillStyle = p.color;
                mctx.strokeStyle = p.active ? '#FFFFFF' : '#666666'; // White outline for active, gray for inactive
                mctx.lineWidth = 1; // Thin but visible outline
                mctx.beginPath();
                mctx.arc(p.x * scale, p.y * scale, Math.max(3, p.radius * scale * 0.5), 0, Math.PI * 2); // Increased minimum size
                mctx.fill();
                mctx.stroke(); // Add outline
                // Optional: Draw player name initials for better identification
                if (p.active) {
                    mctx.fillStyle = '#FFFFFF';
                    mctx.font = 'bold 8px Arial';
                    mctx.textAlign = 'center';
                    mctx.fillText(p.name.charAt(0).toUpperCase(), p.x * scale, p.y * scale + 2);
                }
            }
            mctx.globalAlpha = 1;

            // Highlight own player with a distinct marker
            mctx.fillStyle = myPlayer.color;
            mctx.strokeStyle = '#FFD700'; // Gold outline for self
            mctx.lineWidth = 1.5;
            mctx.beginPath();
            mctx.arc(myPlayer.x * scale, myPlayer.y * scale, Math.max(4, myPlayer.radius * scale * 0.5), 0, Math.PI * 2);
            mctx.fill();
            mctx.stroke();

            const viewX = (myPlayer.x - canvas.width / 2) * scale;
            const viewY = (myPlayer.y - canvas.height / 2) * scale;
            mctx.strokeStyle = '#8B4513';
            mctx.lineWidth = 1;
            mctx.strokeRect(viewX, viewY, canvas.width * scale, canvas.height * scale);

            updateLeaderboard();
            updateHud();

            requestAnimationFrame(renderLoop);
        }

        function getPowerUpColor(type) {
            switch (type) {
                case 'speed': return '#FFD700'; // Gold
                case 'shield': return '#00BFFF'; // Blue
                case 'growth': return '#32CD32'; // Green
                case 'multi-shot': return '#FF4500'; // Orange
                default: return '#FFF';
            }
        }

        function getPowerUpIcon(type) {
            switch (type) {
                case 'speed': return '⚡';
                case 'shield': return '🛡️';
                case 'growth': return '📈';
                case 'multi-shot': return '🔫';
                default: return '?';
            }
        }

        window.onbeforeunload = () => {
            if (myId) {
                db.ref(`players/${myId}`).update({ active: false });
            }
        };

        peer.on('close', () => {
            if (myId) {
                db.ref(`players/${myId}`).update({ active: false });
            }
        });
    </script>
</body>

</html>
